#+TITLE: It's All Gravie!
A job interview project posing as a Library you can borrow games from.

Live site: https://its-all-gravie.justenough.software/
* Overview
  This repo is my response to the prompt posed in [[https://github.com/gravieinc/gravie-developer-test][this repo]] by Gravie Inc. In this readme I will
  cover the following topics:
  - Installation
  - Development Process
  - Challenging parts of the process
  - High-level architectural choices
  - Future work
* Installation
  Before I get into the =what= and =why= of the higher-level choices I made, I'm going to cover how
  to get a local development version up and running, in the event you want to see it in action right
  away.
** Dependencies
   This project relies on at least NodeJS ~v6.0.0+~ (because Shadow CLJS requires that), though I used
   ~v20.5.1~, and a Java SDK (again because Shadow CLJS requires it), at least version ~11~, though I
   used ~OpenJDK 20.0.1~.

   How you install each of those will be dependent upon your OS and particular setup, but likely
   your OS' package manager will have a usable version available.
** Running it locally
   There are two parts to this app (described in more detail in later sections), and they are Shadow
   CLJS and Wrangler. Shadow handles compiling the CLJS files into JS files suitable for the
   browser, and Wrangler handles being our backend.

   For Shadow CLJS, you can either start it from your editor using whatever ClojureScript editor
   integration you've got, or you can use an ~npm~ script to start the server. If you use Emacs, and
   have installed Cider, you can likely use ~cider-jack-in-cljs~ to start the Shadow server and
   connect to it.

   Both Shadow and Wrangler start long running processes, so, if starting both with ~npm~, run the
   following commands in two separate terminals:
   - Shadow CLJS :: ~npm run watch~
   - Wrangler :: ~npm run local-dev~

   Then visit the URL that Wrangler gives you, likely ~http://127.0.0.1:8788/~. Depending on whether
   Shadow has finished compiling the CLJS files or not you might have a short delay, but soon enough
   you'll be staring at the site running locally!
** Seeing it live from a different machine
   If you don't want to do all of that, but /do/ want to see the app live, you can go to
   https://its-all-gravie.justenough.software/, which, assuming it's still running by the time you
   come across this README, is a site running on Cloudflare's Pages technology.
* High-level Design Decisions
  With that out of the way, let's talk about the high level design decisions made for this project.
  Here I'm using =design= in a broader sense than just deciding the look of the UI, but encompassing
  all aspects of building this project.

  Since no design happens in a vacuum, we'll start by discussing the context this project existed
  and exists in, then tackle the various decisions made, starting at the proverbial 30,000 foot
  view, and zooming in.

  I won't promise that this will be an exhaustive review of all of the decisions made, but it should
  cover at least the foundational ones.
** Project Context
*** It's for an interview
    The first, and perhaps most important, piece of context is that I created this project as part of
    the interview process for a Senior Software Engineer position at Gravie Inc., and thus the most
    important goal for this project is that it get me a job at Gravie, or at the very least progress
    me to the next stage of the interview process.

    One piece of context to add up front is that Gravie is aware that the majority of my
    professional experience is in the backend, and primarily (though not exclusively) in Clojure.

    With that in mind, here are some parts of the job posting that struck me as both relevant, and
    also something that can be shown in a solo sample project.
    #+begin_quote
    You will:
    - Work towards a goal of continuous deployments. We currently deliver changes within two-week
      iterations culminating in a release, but understand the value of more frequent continuous
      delivery, and are adapting our tools and processes to support deployments as soon as changes
      are ready
    - Work on a major ongoing architecture overhaul that affects all services, infrastructure, and
      supporting processes
    - Manage the production operations of the services that your team owns, and incorporate changes
      into the current development to improve operations
    - Demonstrate commitment to our core competencies of being authentic, curious, creative,
      empathetic and outcome oriented
    #+end_quote
    From this I'll pull the following goals/bonus points to add to the project context:
    - Show some kind of continuous deployment functionality
    - Demonstrate authenticity, curiosity, creativity, empathy, and outcome orientation

    #+begin_quote
    You bring:
    - Solid programming background and a passion for writing code. You are eager to learn more and
      enjoy providing and receiving critical feedback
    - Advanced programming experience in at least a few of the following programming languages:
      Clojure/ClojureScript, Groovy, Python, Java, JavaScript, Elixir, Kotlin
    - Knowledge and experience with different programming paradigms such as functional programming,
      object oriented, and declarative programming
    - Experience with Clojure/ClojureScript, Groovy/Grails and JavaScript frameworks such as React,
      Ember, Vue.js, or AngularJS
    - Solid knowledge of key value stores, SQL, and relational databases; preferably MySQL
    - Have a great understanding of the value of automated tests, and ability to implement them
      across the whole stack
    - Solid understanding of working in Linux shells
    - Ability to collaborate with designers, product owners, and other cross-functional team members
    - Experience working across the full stack, from user experience, to API design, to
      infrastructure
    - Demonstrate commitment to our core competencies of being authentic, curious, creative,
      empathetic and outcome oriented.
    #+end_quote
    From this I'll pull the following as goals for the project:
    - Show an eagerness to learn things
    - Advanced programming experience in CLJ/CLJS/JS
    - Knowledge and experience with different programming paradigms
    - Experience with CLJ/CLJS and React

    I love automated tests (and am curious about writing frontend tests with CLJS), but writing
    tests is going on the =future work= list, for reasons I'll explain in a later section.

    All of the collaboration elements -- providing/receiving critical feedback, collaborating
    cross-functional team members, demonstrating empathy -- above are hard (impossible?) to
    demonstrate in a solo project, though I love doing those things (and secretly/not-so-secretly
    wish part of the project involved working with other cross-functional team members).

    #+begin_quote
    Extra credit:
    - Experience with Docker and containerized environments
    - Experience with Serverless technologies and AWS Lambda
    - Experience with client side unidirectional data flow patterns
    - Knowledge of building out pipelines using infrastructure-as-code tools such as AWS CDK
    #+end_quote

    From this I'll pull the following as goals for the project:
    - Demonstrate experience with serverless technologies
    - Demonstrate experience with client side unidirectional data flow patterns

    I wanted to leverage Cloudflare's Pages technology for the static assets, and the Pages
    Functions functionality for the backend serverless code, so I'm not going to touch on containers
    or AWS Lambda in this project, though it would be fairly straightforward to add both.

    I also am not going to touch on infrastructure as code, even though setting up, say, terraform
    for cloudflare isn't that difficult, it tends to take a bit of time, and I'm not confident it'd
    have a sufficiently positive impact on my interview process when balanced against the time it'd
    take to write out.
*** The project itself
    The second piece of context is the synopsis from [[file:original-readme.md::For this challenge you will consume the Giant Bomb API to create an application that will allow a][the original readme]]:
    #+begin_src markdown
      For this challenge you will consume the Giant Bomb API to create an application that will allow a
      user to search games and "rent" them. The application should consist of at least two unique pages
      (`search` and `checkout`). Your view should display the game thumbnail and title, and the rest is up
      to you. You can use any language and or framework you'd like. 
    #+end_src

    From which we can add that our app must have or do the following:
    - Have a search page
    - Allow users to search for games using the Giant Bomb API
    - The games displayed should show the game's thumbnail and title
    - Have a checkout page
    - Allow users to "rent" said games
    - Every other decision is up to us
    - We can use any language and framework we'd like

    This is a good start for a problem description, but it's also pretty sparse, which had me
    concerned that just building that functionality and putting little/no effort into styling or a
    couple extra pieces of functionality would leave a bad impression.

    (Sidebar: Why might it leave a bad impression, you ask? Perhaps part of the "test" of the project
    is that building the synopsis, as stated, is actually insufficient for moving to the next round,
    but no one would say so, and I'd be rejected even though I could have built more. I've had
    interviews at other companies that worked like that, which was a bummer, as I could have built
    what they wanted had they asked for it.)

    As such, I reached out to the folks at Gravie who'd posed the project and asked the following
    question:
    #+begin_quote
    How much is enough?

    When given a somewhat open ended prompt, I can tend to over-polish it, never quite sure if the
    prompt-as-written is enough to move on to the next stage, or if there’s secretly more being hoped
    for. I normally work with stakeholders on projects to resolve ambiguities, but in the case of
    interview-specific projects it’s never immediately clear on who the stakeholders would be, or how
    much time they’d like to spend hashing out ambiguities.

    So, to avoid endlessly working on this project and never actually present it, my current plan was
    to build specifically what was asked for in the README and then check in with you both to see if
    that was sufficient to engender confidence in moving to the next phase, or if there were specific
    things you were hoping to see that I hadn’t covered yet. I’d like to make sure the work I’m doing
    is giving good signal for the things you’re looking for, and this seemed like the simplest
    approach to me.

    Does that sound like a good approach for you both? I’m also open to other approaches, so I
    welcome alternatives :)
    #+end_quote

    Gravie replied:
    #+begin_quote
    Keep in mind that this is just a sample of your work, it is not expected to be production ready
    code!

    Perhaps my favorite part of the project is the discussion with you about everything else that
    would have to be done to take it further. One good approach to that is to keep a running list in
    a README about future work as if it were to be taken all the way to production.

    In short, show us your work with the intent to impress us AND to stimulate further discussion.
    #+end_quote

    From this we can add the following pieces of context:
    - Their expectation is that this is only a sample of my work, from which I presume that having
      some rough edges is ok
    - Having a list of things I didn't build, or would build next, is a good signal for Gravie
    - Whatever I build, I should build it with the intention of impressing them, and also with the
      intention of stimulating further discussion

    I'm both grateful for the response -- everyone at Gravie has been really lovely, and I'm not
    saying that just cause they might read this 😂 -- and also I would have loved more specifics on
    what they find impressive, as the list of possibly impressive things is likely infinite.

    That said, I'd only known these folks for a 45 minute interview, and wasn't sure if seeking more
    details about what =impressive= means to them would come across well or not. Since I couldn't be
    sure what kind of impact that'd have on my prospects, I chose instead to build what would impress
    me, and hope that they'd also find it impressive (and hopefully ask for anything else they wanted
    to see).
*** Context Summary
    So, as a list, here's the context influencing all decisions for this project:
    - The core goal of the project is to impress the folks at Gravie well enough to move me to the
      next phase of the interview process
    - Gravie knows that the majority of my experience is on the backend
    - Show some kind of continuous deployment functionality
    - Demonstrate authenticity, curiosity, creativity, empathy, and outcome orientation
    - Show an eagerness to learn things
    - Demonstrate advanced programming experience in CLJ/CLJS/JS
    - Demonstrate knowledge and experience with different programming paradigms
    - Demonstrate experience with React
    - Demonstrate experience with serverless technologies
    - Demonstrate experience with client side unidirectional data flow patterns
    - It must use the Giant Bomb API to search for games
    - It needs a discrete =search= page
    - Each game displayed must show the game' thumbnail and title
    - It needs a discrete =checkout= page
    - It must allow users to =rent= games
    - Every other decision is up to me
    - I can use any language and/or framework I want
    - Their expectation is that this is only a sample of my work, from which I presume that having
      some rough edges is ok
    - Having a list of things I didn't build, or would build next, is a good signal for Gravie
    - Whatever I build, I should build it with the intention of impressing them, and also with the
      intention of stimulating further discussion
    - I do not actually know what they would find impressive, so I will instead aim to impress myself
      and hope that we happen to find the same things impressive
    - Taking longer on the project has a risk of diminishing how impressive Gravie finds it, so I
      need to incorporate speed of delivery into the equation when making design decisions
** 30,000ft View
   Now that we know the influencing forces behind the project, let's sort out some of the major
   decisions.

   First off, we know that we need to have a UI, and thus some kind of frontend, and, since Giant
   Bomb doesn't implement CORS, we'll also need a backend since browsers will block cross-origin
   requests to any resource that doesn't include the right CORS headers. This is inconvenient for
   our small project -- which will never actually see production -- but very good for the world, so
   we'll add a backend.

   We've got the following data needs:
   - We'll need an API key to make search requests to Giant Bomb.
   - A way to store the search results so that they can be rendered to the user
   - A way to store the games a user wants to =rent=, specifically to support a checkout page
*** How much backend, and how much frontend?
    The vast majority of my experience is with backend code, so it'd be reasonable to assume that
    I'd want to lean heavily into the backend and make a sparse frontend. That, however, isn't the
    direction I decided to go in, and here's why.

    First, from my experience with consulting, and from working with PMs/Users/non-technical
    stakeholders, I have first hand experience that a sparse or ugly UI immediately leaves a bad
    impression that can overshadow everything else that's going on. It's the classic =sell the
    sizzle, not the sausage= adage, and when mixed with the fact that I don't know what Gravie will
    find impressive, I'm going to try to lean into the sizzle more.

    Second, having worked so much in the backend, and knowing the limited scope of this project, I
    know that there aren't any computational constraints -- such as fast CPU or lots of memory --
    that would benefit from having a backend. Everything that needs to be done -- save the CORS part
    -- can be done in just about any modern browser as well as in any backend.

    Third, there's not a lot of novelty, for me, in building a backend for this project, which also
    leads me to feel less impressed by writing one. Now, Gravie doesn't know me well, so they may
    see whatever kind of backend I'd write -- likely something using [[https://github.com/metosin/reitit][reitit]], [[https://github.com/metosin/malli][malli]], [[http://pedestal.io/index][pedestal]], and
    then probably mysql because Gravie uses it and it'd be good to incorporate tech they're using --
    and would be impressed, but I can't know that with any confidence. At this point in the CLJ
    ecosystem's lifecycle, the kind of backend this project would need is pretty bog-standard, and
    thus I don't think it'd stand out enough, or properly give a sense for the scope of work I can
    do.

    So, given all of that, I decided to put most of the work into building the frontend, and keep
    the backend as simple as possible. This meant, in effect, making it a simple proxy for the Giant
    Bomb API. I'll talk more about the specific choices around building that in a later section.

    Since our backend will be a simple proxy for Giant Bomb, we'll meet our data needs in whatever
    frontend tech we choose.
*** How much infrastructure?
    Similar to the backend, I've done a lot of ops/devops/infrastructure work, and know that there
    isn't, fundamentally, a lot of interesting infrastructure needed for this project. We need
    something to serve the frontend assets, something to handle HTTP requests sent to the backend.
    It can get a little more complicated if we want a live version of this running somewhere -- I
    don't memorize a list of all possible combinations of infra you'd need to accomplish this
    because it's simple enough to put all of the pieces together once you begin doing it, but it
    includes at least DNS records, some amount of networking, and one or two somethings serving
    assets and handling backend requests -- but a live version running somewhere isn't required for
    this project.

    It is, however, impressive to have a live version, which means I'd like to have one while
    spending as little time and effort on infrastructure as possible.
** 10,000ft View
   Zooming in, we now need to make choices about the major frontend and backend tech we're going to
   use.
*** Frontend Tech
    Now, I've decided to put the majority of my efforts into building a frontend, but I've got very
    little experience building frontends, which means just about every choice is a novel one, and I
    need to be aware of, and avoid as best as possible, potential complexity traps, since the frontend
    is a relative ocean of tech choices.

    Among these potential complexity traps are:
    - HTML :: everything's a ~div~, except when it isn't, or shouldn't be
      - I personally really like semantic HTML, but don't know all the various element types, thus
        why this is a complexity trap
    - CSS :: This is important for making something look =nice=, but, from the various FE coworkers
      I've chatted with, and the various blogs I've read, this sounds like it's an even bigger ocean
      than HTML is
    - JS :: Keeping the backend as a simple proxy means I'll need to leverage JS in some form. It's
      possible that HTML/CSS/web tech has advanced enough that this isn't true anymore, but that's
      well outside my wheelhouse, so I'm going to move forward with a JS SPA/UI framework. This also
      includes things like the ~Fetch~ tech requiring CORS from a remote resource before it will
      give a JSON payload back to the JS that requested it, though that's a pretty shallow trap.

    Since I don't have extensive experience with frontend development, every tech choice's set of
    potential complexity traps has, as far as I can know, roughly the same cardinality of infinity,
    with the following exceptions:
    - React
    - CLJS
    - Bootstrap/Material UI

    Long, long ago, in what is now, perhaps, ancient history for the Web (2015, to be precise), I
    worked on a project using [[https://github.com/omcljs/om/][Om.Next]] (which was a CLJS framework over React), Datascript (an
    immutable CLJS DB), and Bootstrap (then just a CSS library, if memory serves).

    I've also worked very sparingly on a project that was using CoffeeScript and Angular 1, which
    gave me an introduction to the various JS build tooling.

    From those experiences, I definitely prefer ClojureScript and it's build tooling, and I also
    learned that, as much as possible, it's best to follow the crowd with JS libraries, as most
    issues you run into will have readily available answers on the web already.

    Lucky for me, Gravie is using [[https://github.com/day8/re-frame/][re-frame]], which is a CLJS framework (built on [[https://reagent-project.github.io/][reagent]]) for React,
    and doubly-lucky for me, I've been really curious about re-frame for a while and was looking for
    a reason to learn it!

    For the styling, I'd like to leverage an existing CSS framework, with a preference for one that
    that's been proven to work well with re-frame/reagent, so I minimize the number of complexity
    traps I might fall into.
